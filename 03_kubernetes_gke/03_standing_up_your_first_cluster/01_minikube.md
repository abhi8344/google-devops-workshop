# Minikube

[Minikube](https://github.com/kubernetes/minikube) is a tool that makes it easy to run Kubernetes locally. Minikube runs a single-node Kubernetes cluster inside a VM on your laptop for users looking to try out Kubernetes or develop with it day-to-day.

* Install Minikube:
```
$ curl -Lo minikube <nowiki>https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64</nowiki> \
    && chmod +x minikube && sudo mv minikube /usr/local/bin/
```

* Install kubectl (note: we go into greater detail on kubectl in an [upcoming section](03_kubectl.md)):
```
$ curl -Lo kubectl <nowiki>https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl</nowiki> \
    && chmod +x kubectl && sudo mv kubectl /usr/local/bin/
```

* Test install:
```
$ minikube start
$ minikube status
$ minikube dashboard
$ kubectl config view
$ kubectl cluster-info
$ minikube stop
```

Get the details on the CLI options for kubectl in our upcoming section on [kubectl](03_kubectl).

## Quickstart

Below is a brief demo of Minikube usage.

NOTE: If you want to change the VM driver add the appropriate `--vm-driver=xxx` flag to `minikube start`. Minikube supports the following drivers:

* virtualbox
* vmwarefusion
* KVM2
* KVM (deprecated in favor of KVM2)
* hyperkit
* xhyve
* hyperv
* none (Linux-only) - this driver can be used to run the Kubernetes cluster components on the host instead of in a VM. This can be useful for CI workloads which do not support nested virtualization.

* Start up minikube:
```
$ minikube start
Starting local Kubernetes v1.10.0 cluster...
Starting VM...
SSH-ing files into VM...
Setting up certs...
Starting cluster components...
Connecting to cluster...
Setting up kubeconfig...
Kubectl is now configured to use the cluster.
```

* Create a Deployment:
```
$ kubectl run hello-minikube --image=k8s.gcr.io/echoserver:1.4 --port=8080
deployment.apps/hello-minikube created
```

* Expose the Deployment by creating a Service (of type `NodePort`):
```
$ kubectl expose deployment hello-minikube --type=NodePort
service/hello-minikube exposed
```

We have now launched an "echos erver" Pod, but we have to wait until the Pod is up before curling/accessing it via the exposed Service.

* To check whether the Pod is up and running, we can use the following:
```
$ kubectl get pod --watch
NAME                               READY     STATUS    RESTARTS   AGE
hello-minikube-6c47c66d8-hn457     1/1       Running   0          13s
```

* Once the Pod is "Running", we can now curl the Service:
```
$ curl $(minikube service hello-minikube --url)
CLIENT VALUES:
client_address=172.17.0.1
command=GET
real path=/
query=nil
request_version=1.1
request_uri=http://192.168.99.100:8080/

SERVER VALUES:
server_version=nginx: 1.10.0 - lua: 10001

HEADERS RECEIVED:
accept=*/*
host=192.168.99.100:31470
user-agent=curl/7.58.0
BODY:
-no body in request-
```

* Cleanup:
```
$ kubectl delete service hello-minikube
service "hello-minikube" deleted

$ kubectl delete deployment hello-minikube
deployment.extensions "hello-minikube" deleted
```

## Proxy and dashboard

Using the `kubectl proxy` command, kubectl will authenticate with the API Server on the Master Node and would make the dashboard available on <code>http://localhost:8001/ui</code>:
```
$ kubectl proxy
Starting to serve on 127.0.0.1:8001
```

After running the above command, we can access the dashboard at <code>http://127.0.0.1:8001/ui</code>.

Once the kubectl proxy is configured, we can send requests to localhost on the proxy port:
```
$ curl http://localhost:8001/
$ curl http://localhost:8001/version

{
  "major": "1",
  "minor": "10",
  "gitVersion": "v1.10.0",
  "gitCommit": "fc32d2f3698e36b93322a3465f63a14e9f0eaead",
  "gitTreeState": "clean",
  "buildDate": "2018-03-26T16:44:10Z",
  "goVersion": "go1.9.3",
  "compiler": "gc",
  "platform": "linux/amd64"
}
```

## API

Without kubectl proxy configured, we can get the Bearer Token using kubectl, and then send it with the API request. A Bearer Token is an access token which is generated by the authentication server (the API server on the Master Node) and given back to the client. Using that token, the client can connect back to the Kubernetes API server without providing further authentication details, and then, access resources.

* Get the k8s token:
```
$ TOKEN=$(kubectl describe secret $(kubectl get secrets | awk '/^default/{print $1}') | awk '/^token/{print $2}')
```

* Get the k8s API server endpoint:
```
$ APISERVER=$(kubectl config view | awk '/https/{print $2}')
```

* Access the API Server:
```
$ curl -k -H "Authorization: Bearer ${TOKEN}" ${APISERVER}
```
